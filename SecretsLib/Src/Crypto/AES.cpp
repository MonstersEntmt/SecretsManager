#include "Crypto/Crypto.h"

#include <cstring>

#include <bit>

namespace Crypto
{
	enum class EBCM : uint8_t
	{
		ECB,
		CBC
	};

	struct alignas(16) AESBlock
	{
		uint32_t Words[4];
	};

	struct AESState
	{
		AESBlock TempBlock;
		AESBlock CBCIV;
		AESBlock Keys[15];

		EBCM    BCM;
		uint8_t Nk;
		uint8_t Nr;
		uint8_t TempBlockUsed;

		size_t Count;
	};

	static constexpr uint8_t c_AESSBox[]     = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 };
	static constexpr uint8_t c_AESInvSBox[]  = { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D };
	static constexpr uint8_t c_AESXTimes02[] = { 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5 };
	static constexpr uint8_t c_AESXTimes04[] = { 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c, 0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c, 0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c, 0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c, 0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc, 0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc, 0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc, 0x1b, 0x1f, 0x13, 0x17, 0x0b, 0x0f, 0x03, 0x07, 0x3b, 0x3f, 0x33, 0x37, 0x2b, 0x2f, 0x23, 0x27, 0x5b, 0x5f, 0x53, 0x57, 0x4b, 0x4f, 0x43, 0x47, 0x7b, 0x7f, 0x73, 0x77, 0x6b, 0x6f, 0x63, 0x67, 0x9b, 0x9f, 0x93, 0x97, 0x8b, 0x8f, 0x83, 0x87, 0xbb, 0xbf, 0xb3, 0xb7, 0xab, 0xaf, 0xa3, 0xa7, 0xdb, 0xdf, 0xd3, 0xd7, 0xcb, 0xcf, 0xc3, 0xc7, 0xfb, 0xff, 0xf3, 0xf7, 0xeb, 0xef, 0xe3, 0xe7, 0x36, 0x32, 0x3e, 0x3a, 0x26, 0x22, 0x2e, 0x2a, 0x16, 0x12, 0x1e, 0x1a, 0x06, 0x02, 0x0e, 0x0a, 0x76, 0x72, 0x7e, 0x7a, 0x66, 0x62, 0x6e, 0x6a, 0x56, 0x52, 0x5e, 0x5a, 0x46, 0x42, 0x4e, 0x4a, 0xb6, 0xb2, 0xbe, 0xba, 0xa6, 0xa2, 0xae, 0xaa, 0x96, 0x92, 0x9e, 0x9a, 0x86, 0x82, 0x8e, 0x8a, 0xf6, 0xf2, 0xfe, 0xfa, 0xe6, 0xe2, 0xee, 0xea, 0xd6, 0xd2, 0xde, 0xda, 0xc6, 0xc2, 0xce, 0xca, 0x2d, 0x29, 0x25, 0x21, 0x3d, 0x39, 0x35, 0x31, 0x0d, 0x09, 0x05, 0x01, 0x1d, 0x19, 0x15, 0x11, 0x6d, 0x69, 0x65, 0x61, 0x7d, 0x79, 0x75, 0x71, 0x4d, 0x49, 0x45, 0x41, 0x5d, 0x59, 0x55, 0x51, 0xad, 0xa9, 0xa5, 0xa1, 0xbd, 0xb9, 0xb5, 0xb1, 0x8d, 0x89, 0x85, 0x81, 0x9d, 0x99, 0x95, 0x91, 0xed, 0xe9, 0xe5, 0xe1, 0xfd, 0xf9, 0xf5, 0xf1, 0xcd, 0xc9, 0xc5, 0xc1, 0xdd, 0xd9, 0xd5, 0xd1 };
	static constexpr uint8_t c_AESXTimes08[] = { 0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78, 0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8, 0xc0, 0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0, 0xf8, 0x1b, 0x13, 0x0b, 0x03, 0x3b, 0x33, 0x2b, 0x23, 0x5b, 0x53, 0x4b, 0x43, 0x7b, 0x73, 0x6b, 0x63, 0x9b, 0x93, 0x8b, 0x83, 0xbb, 0xb3, 0xab, 0xa3, 0xdb, 0xd3, 0xcb, 0xc3, 0xfb, 0xf3, 0xeb, 0xe3, 0x36, 0x3e, 0x26, 0x2e, 0x16, 0x1e, 0x06, 0x0e, 0x76, 0x7e, 0x66, 0x6e, 0x56, 0x5e, 0x46, 0x4e, 0xb6, 0xbe, 0xa6, 0xae, 0x96, 0x9e, 0x86, 0x8e, 0xf6, 0xfe, 0xe6, 0xee, 0xd6, 0xde, 0xc6, 0xce, 0x2d, 0x25, 0x3d, 0x35, 0x0d, 0x05, 0x1d, 0x15, 0x6d, 0x65, 0x7d, 0x75, 0x4d, 0x45, 0x5d, 0x55, 0xad, 0xa5, 0xbd, 0xb5, 0x8d, 0x85, 0x9d, 0x95, 0xed, 0xe5, 0xfd, 0xf5, 0xcd, 0xc5, 0xdd, 0xd5, 0x6c, 0x64, 0x7c, 0x74, 0x4c, 0x44, 0x5c, 0x54, 0x2c, 0x24, 0x3c, 0x34, 0x0c, 0x04, 0x1c, 0x14, 0xec, 0xe4, 0xfc, 0xf4, 0xcc, 0xc4, 0xdc, 0xd4, 0xac, 0xa4, 0xbc, 0xb4, 0x8c, 0x84, 0x9c, 0x94, 0x77, 0x7f, 0x67, 0x6f, 0x57, 0x5f, 0x47, 0x4f, 0x37, 0x3f, 0x27, 0x2f, 0x17, 0x1f, 0x07, 0x0f, 0xf7, 0xff, 0xe7, 0xef, 0xd7, 0xdf, 0xc7, 0xcf, 0xb7, 0xbf, 0xa7, 0xaf, 0x97, 0x9f, 0x87, 0x8f, 0x5a, 0x52, 0x4a, 0x42, 0x7a, 0x72, 0x6a, 0x62, 0x1a, 0x12, 0x0a, 0x02, 0x3a, 0x32, 0x2a, 0x22, 0xda, 0xd2, 0xca, 0xc2, 0xfa, 0xf2, 0xea, 0xe2, 0x9a, 0x92, 0x8a, 0x82, 0xba, 0xb2, 0xaa, 0xa2, 0x41, 0x49, 0x51, 0x59, 0x61, 0x69, 0x71, 0x79, 0x01, 0x09, 0x11, 0x19, 0x21, 0x29, 0x31, 0x39, 0xc1, 0xc9, 0xd1, 0xd9, 0xe1, 0xe9, 0xf1, 0xf9, 0x81, 0x89, 0x91, 0x99, 0xa1, 0xa9, 0xb1, 0xb9 };
	static constexpr uint8_t c_AESXTimes10[] = { 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0x1b, 0x0b, 0x3b, 0x2b, 0x5b, 0x4b, 0x7b, 0x6b, 0x9b, 0x8b, 0xbb, 0xab, 0xdb, 0xcb, 0xfb, 0xeb, 0x36, 0x26, 0x16, 0x06, 0x76, 0x66, 0x56, 0x46, 0xb6, 0xa6, 0x96, 0x86, 0xf6, 0xe6, 0xd6, 0xc6, 0x2d, 0x3d, 0x0d, 0x1d, 0x6d, 0x7d, 0x4d, 0x5d, 0xad, 0xbd, 0x8d, 0x9d, 0xed, 0xfd, 0xcd, 0xdd, 0x6c, 0x7c, 0x4c, 0x5c, 0x2c, 0x3c, 0x0c, 0x1c, 0xec, 0xfc, 0xcc, 0xdc, 0xac, 0xbc, 0x8c, 0x9c, 0x77, 0x67, 0x57, 0x47, 0x37, 0x27, 0x17, 0x07, 0xf7, 0xe7, 0xd7, 0xc7, 0xb7, 0xa7, 0x97, 0x87, 0x5a, 0x4a, 0x7a, 0x6a, 0x1a, 0x0a, 0x3a, 0x2a, 0xda, 0xca, 0xfa, 0xea, 0x9a, 0x8a, 0xba, 0xaa, 0x41, 0x51, 0x61, 0x71, 0x01, 0x11, 0x21, 0x31, 0xc1, 0xd1, 0xe1, 0xf1, 0x81, 0x91, 0xa1, 0xb1, 0xd8, 0xc8, 0xf8, 0xe8, 0x98, 0x88, 0xb8, 0xa8, 0x58, 0x48, 0x78, 0x68, 0x18, 0x08, 0x38, 0x28, 0xc3, 0xd3, 0xe3, 0xf3, 0x83, 0x93, 0xa3, 0xb3, 0x43, 0x53, 0x63, 0x73, 0x03, 0x13, 0x23, 0x33, 0xee, 0xfe, 0xce, 0xde, 0xae, 0xbe, 0x8e, 0x9e, 0x6e, 0x7e, 0x4e, 0x5e, 0x2e, 0x3e, 0x0e, 0x1e, 0xf5, 0xe5, 0xd5, 0xc5, 0xb5, 0xa5, 0x95, 0x85, 0x75, 0x65, 0x55, 0x45, 0x35, 0x25, 0x15, 0x05, 0xb4, 0xa4, 0x94, 0x84, 0xf4, 0xe4, 0xd4, 0xc4, 0x34, 0x24, 0x14, 0x04, 0x74, 0x64, 0x54, 0x44, 0xaf, 0xbf, 0x8f, 0x9f, 0xef, 0xff, 0xcf, 0xdf, 0x2f, 0x3f, 0x0f, 0x1f, 0x6f, 0x7f, 0x4f, 0x5f, 0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2, 0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72, 0x99, 0x89, 0xb9, 0xa9, 0xd9, 0xc9, 0xf9, 0xe9, 0x19, 0x09, 0x39, 0x29, 0x59, 0x49, 0x79, 0x69 };
	static constexpr uint8_t c_AESXTimes20[] = { 0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0x1b, 0x3b, 0x5b, 0x7b, 0x9b, 0xbb, 0xdb, 0xfb, 0x36, 0x16, 0x76, 0x56, 0xb6, 0x96, 0xf6, 0xd6, 0x2d, 0x0d, 0x6d, 0x4d, 0xad, 0x8d, 0xed, 0xcd, 0x6c, 0x4c, 0x2c, 0x0c, 0xec, 0xcc, 0xac, 0x8c, 0x77, 0x57, 0x37, 0x17, 0xf7, 0xd7, 0xb7, 0x97, 0x5a, 0x7a, 0x1a, 0x3a, 0xda, 0xfa, 0x9a, 0xba, 0x41, 0x61, 0x01, 0x21, 0xc1, 0xe1, 0x81, 0xa1, 0xd8, 0xf8, 0x98, 0xb8, 0x58, 0x78, 0x18, 0x38, 0xc3, 0xe3, 0x83, 0xa3, 0x43, 0x63, 0x03, 0x23, 0xee, 0xce, 0xae, 0x8e, 0x6e, 0x4e, 0x2e, 0x0e, 0xf5, 0xd5, 0xb5, 0x95, 0x75, 0x55, 0x35, 0x15, 0xb4, 0x94, 0xf4, 0xd4, 0x34, 0x14, 0x74, 0x54, 0xaf, 0x8f, 0xef, 0xcf, 0x2f, 0x0f, 0x6f, 0x4f, 0x82, 0xa2, 0xc2, 0xe2, 0x02, 0x22, 0x42, 0x62, 0x99, 0xb9, 0xd9, 0xf9, 0x19, 0x39, 0x59, 0x79, 0xab, 0x8b, 0xeb, 0xcb, 0x2b, 0x0b, 0x6b, 0x4b, 0xb0, 0x90, 0xf0, 0xd0, 0x30, 0x10, 0x70, 0x50, 0x9d, 0xbd, 0xdd, 0xfd, 0x1d, 0x3d, 0x5d, 0x7d, 0x86, 0xa6, 0xc6, 0xe6, 0x06, 0x26, 0x46, 0x66, 0xc7, 0xe7, 0x87, 0xa7, 0x47, 0x67, 0x07, 0x27, 0xdc, 0xfc, 0x9c, 0xbc, 0x5c, 0x7c, 0x1c, 0x3c, 0xf1, 0xd1, 0xb1, 0x91, 0x71, 0x51, 0x31, 0x11, 0xea, 0xca, 0xaa, 0x8a, 0x6a, 0x4a, 0x2a, 0x0a, 0x73, 0x53, 0x33, 0x13, 0xf3, 0xd3, 0xb3, 0x93, 0x68, 0x48, 0x28, 0x08, 0xe8, 0xc8, 0xa8, 0x88, 0x45, 0x65, 0x05, 0x25, 0xc5, 0xe5, 0x85, 0xa5, 0x5e, 0x7e, 0x1e, 0x3e, 0xde, 0xfe, 0x9e, 0xbe, 0x1f, 0x3f, 0x5f, 0x7f, 0x9f, 0xbf, 0xdf, 0xff, 0x04, 0x24, 0x44, 0x64, 0x84, 0xa4, 0xc4, 0xe4, 0x29, 0x09, 0x69, 0x49, 0xa9, 0x89, 0xe9, 0xc9, 0x32, 0x12, 0x72, 0x52, 0xb2, 0x92, 0xf2, 0xd2 };
	static constexpr uint8_t c_AESXTimes40[] = { 0x00, 0x40, 0x80, 0xc0, 0x1b, 0x5b, 0x9b, 0xdb, 0x36, 0x76, 0xb6, 0xf6, 0x2d, 0x6d, 0xad, 0xed, 0x6c, 0x2c, 0xec, 0xac, 0x77, 0x37, 0xf7, 0xb7, 0x5a, 0x1a, 0xda, 0x9a, 0x41, 0x01, 0xc1, 0x81, 0xd8, 0x98, 0x58, 0x18, 0xc3, 0x83, 0x43, 0x03, 0xee, 0xae, 0x6e, 0x2e, 0xf5, 0xb5, 0x75, 0x35, 0xb4, 0xf4, 0x34, 0x74, 0xaf, 0xef, 0x2f, 0x6f, 0x82, 0xc2, 0x02, 0x42, 0x99, 0xd9, 0x19, 0x59, 0xab, 0xeb, 0x2b, 0x6b, 0xb0, 0xf0, 0x30, 0x70, 0x9d, 0xdd, 0x1d, 0x5d, 0x86, 0xc6, 0x06, 0x46, 0xc7, 0x87, 0x47, 0x07, 0xdc, 0x9c, 0x5c, 0x1c, 0xf1, 0xb1, 0x71, 0x31, 0xea, 0xaa, 0x6a, 0x2a, 0x73, 0x33, 0xf3, 0xb3, 0x68, 0x28, 0xe8, 0xa8, 0x45, 0x05, 0xc5, 0x85, 0x5e, 0x1e, 0xde, 0x9e, 0x1f, 0x5f, 0x9f, 0xdf, 0x04, 0x44, 0x84, 0xc4, 0x29, 0x69, 0xa9, 0xe9, 0x32, 0x72, 0xb2, 0xf2, 0x4d, 0x0d, 0xcd, 0x8d, 0x56, 0x16, 0xd6, 0x96, 0x7b, 0x3b, 0xfb, 0xbb, 0x60, 0x20, 0xe0, 0xa0, 0x21, 0x61, 0xa1, 0xe1, 0x3a, 0x7a, 0xba, 0xfa, 0x17, 0x57, 0x97, 0xd7, 0x0c, 0x4c, 0x8c, 0xcc, 0x95, 0xd5, 0x15, 0x55, 0x8e, 0xce, 0x0e, 0x4e, 0xa3, 0xe3, 0x23, 0x63, 0xb8, 0xf8, 0x38, 0x78, 0xf9, 0xb9, 0x79, 0x39, 0xe2, 0xa2, 0x62, 0x22, 0xcf, 0x8f, 0x4f, 0x0f, 0xd4, 0x94, 0x54, 0x14, 0xe6, 0xa6, 0x66, 0x26, 0xfd, 0xbd, 0x7d, 0x3d, 0xd0, 0x90, 0x50, 0x10, 0xcb, 0x8b, 0x4b, 0x0b, 0x8a, 0xca, 0x0a, 0x4a, 0x91, 0xd1, 0x11, 0x51, 0xbc, 0xfc, 0x3c, 0x7c, 0xa7, 0xe7, 0x27, 0x67, 0x3e, 0x7e, 0xbe, 0xfe, 0x25, 0x65, 0xa5, 0xe5, 0x08, 0x48, 0x88, 0xc8, 0x13, 0x53, 0x93, 0xd3, 0x52, 0x12, 0xd2, 0x92, 0x49, 0x09, 0xc9, 0x89, 0x64, 0x24, 0xe4, 0xa4, 0x7f, 0x3f, 0xff, 0xbf };
	static constexpr uint8_t c_AESXTimes80[] = { 0x00, 0x80, 0x1b, 0x9b, 0x36, 0xb6, 0x2d, 0xad, 0x6c, 0xec, 0x77, 0xf7, 0x5a, 0xda, 0x41, 0xc1, 0xd8, 0x58, 0xc3, 0x43, 0xee, 0x6e, 0xf5, 0x75, 0xb4, 0x34, 0xaf, 0x2f, 0x82, 0x02, 0x99, 0x19, 0xab, 0x2b, 0xb0, 0x30, 0x9d, 0x1d, 0x86, 0x06, 0xc7, 0x47, 0xdc, 0x5c, 0xf1, 0x71, 0xea, 0x6a, 0x73, 0xf3, 0x68, 0xe8, 0x45, 0xc5, 0x5e, 0xde, 0x1f, 0x9f, 0x04, 0x84, 0x29, 0xa9, 0x32, 0xb2, 0x4d, 0xcd, 0x56, 0xd6, 0x7b, 0xfb, 0x60, 0xe0, 0x21, 0xa1, 0x3a, 0xba, 0x17, 0x97, 0x0c, 0x8c, 0x95, 0x15, 0x8e, 0x0e, 0xa3, 0x23, 0xb8, 0x38, 0xf9, 0x79, 0xe2, 0x62, 0xcf, 0x4f, 0xd4, 0x54, 0xe6, 0x66, 0xfd, 0x7d, 0xd0, 0x50, 0xcb, 0x4b, 0x8a, 0x0a, 0x91, 0x11, 0xbc, 0x3c, 0xa7, 0x27, 0x3e, 0xbe, 0x25, 0xa5, 0x08, 0x88, 0x13, 0x93, 0x52, 0xd2, 0x49, 0xc9, 0x64, 0xe4, 0x7f, 0xff, 0x9a, 0x1a, 0x81, 0x01, 0xac, 0x2c, 0xb7, 0x37, 0xf6, 0x76, 0xed, 0x6d, 0xc0, 0x40, 0xdb, 0x5b, 0x42, 0xc2, 0x59, 0xd9, 0x74, 0xf4, 0x6f, 0xef, 0x2e, 0xae, 0x35, 0xb5, 0x18, 0x98, 0x03, 0x83, 0x31, 0xb1, 0x2a, 0xaa, 0x07, 0x87, 0x1c, 0x9c, 0x5d, 0xdd, 0x46, 0xc6, 0x6b, 0xeb, 0x70, 0xf0, 0xe9, 0x69, 0xf2, 0x72, 0xdf, 0x5f, 0xc4, 0x44, 0x85, 0x05, 0x9e, 0x1e, 0xb3, 0x33, 0xa8, 0x28, 0xd7, 0x57, 0xcc, 0x4c, 0xe1, 0x61, 0xfa, 0x7a, 0xbb, 0x3b, 0xa0, 0x20, 0x8d, 0x0d, 0x96, 0x16, 0x0f, 0x8f, 0x14, 0x94, 0x39, 0xb9, 0x22, 0xa2, 0x63, 0xe3, 0x78, 0xf8, 0x55, 0xd5, 0x4e, 0xce, 0x7c, 0xfc, 0x67, 0xe7, 0x4a, 0xca, 0x51, 0xd1, 0x10, 0x90, 0x0b, 0x8b, 0x26, 0xa6, 0x3d, 0xbd, 0xa4, 0x24, 0xbf, 0x3f, 0x92, 0x12, 0x89, 0x09, 0xc8, 0x48, 0xd3, 0x53, 0xfe, 0x7e, 0xe5, 0x65 };

	template <uint8_t B>
	static constexpr uint8_t AES_XTimes(uint8_t a)
	{
		uint8_t o = 0;
		if constexpr (B & 0x01) o ^= a;
		if constexpr (B & 0x02) o ^= c_AESXTimes02[a];
		if constexpr (B & 0x04) o ^= c_AESXTimes04[a];
		if constexpr (B & 0x08) o ^= c_AESXTimes08[a];
		if constexpr (B & 0x10) o ^= c_AESXTimes10[a];
		if constexpr (B & 0x20) o ^= c_AESXTimes20[a];
		if constexpr (B & 0x40) o ^= c_AESXTimes40[a];
		if constexpr (B & 0x80) o ^= c_AESXTimes80[a];
		return o;
	}

	static void AES_AddRoundKey(AESBlock* block, const AESBlock* roundKey)
	{
		uint64_t*       pB = (uint64_t*) block;
		const uint64_t* pK = (const uint64_t*) roundKey;
		pB[0]             ^= pK[0];
		pB[1]             ^= pK[1];
	}

	static uint32_t AES_SBox32(uint32_t value)
	{
		return c_AESSBox[value & 0xFF] |
			   c_AESSBox[(value >> 8) & 0xFF] << 8 |
			   c_AESSBox[(value >> 16) & 0xFF] << 16 |
			   c_AESSBox[(value >> 24) & 0xFF] << 24;
	}

	static void AES_SBox128(AESBlock* block)
	{
		uint8_t* pB = (uint8_t*) block;
		for (size_t i = 0; i < 16; ++i)
			pB[i] = c_AESSBox[pB[i]];
	}

	static void AES_ShiftRows(AESBlock* block)
	{
		AESBlock copy;
		memcpy(&copy, block, 16);
		uint8_t* pC = (uint8_t*) &copy;
		uint8_t* pB = (uint8_t*) block;
		for (size_t i = 1; i < 4; ++i)
		{
			for (size_t j = 0; j < 4; ++j)
				pB[i + j * 4] = pC[i + ((j + i) & 3) * 4];
		}
	}

	static void AES_MixColumns(AESBlock* block)
	{
		uint32_t* pB = (uint32_t*) block;
		for (size_t i = 0; i < 4; ++i)
		{
			uint32_t copy = pB[i];
			uint8_t* p    = (uint8_t*) &pB[i];
			uint8_t* c    = (uint8_t*) &copy;
			p[0]          = AES_XTimes<0x02>(c[0]) ^ AES_XTimes<0x03>(c[1]) ^ AES_XTimes<0x01>(c[2]) ^ AES_XTimes<0x01>(c[3]);
			p[1]          = AES_XTimes<0x02>(c[1]) ^ AES_XTimes<0x03>(c[2]) ^ AES_XTimes<0x01>(c[3]) ^ AES_XTimes<0x01>(c[0]);
			p[2]          = AES_XTimes<0x02>(c[2]) ^ AES_XTimes<0x03>(c[3]) ^ AES_XTimes<0x01>(c[0]) ^ AES_XTimes<0x01>(c[1]);
			p[3]          = AES_XTimes<0x02>(c[3]) ^ AES_XTimes<0x03>(c[0]) ^ AES_XTimes<0x01>(c[1]) ^ AES_XTimes<0x01>(c[2]);
		}
	}

	static void AES_InvSBox128(AESBlock* block)
	{
		uint8_t* pB = (uint8_t*) block;
		for (size_t i = 0; i < 16; ++i)
			pB[i] = c_AESInvSBox[pB[i]];
	}

	static void AES_InvShiftRows(AESBlock* block)
	{
		AESBlock copy;
		memcpy(&copy, block, 16);
		uint8_t* pC = (uint8_t*) &copy;
		uint8_t* pB = (uint8_t*) block;
		for (size_t i = 1; i < 4; ++i)
		{
			for (size_t j = 0; j < 4; ++j)
				pB[i + j * 4] = pC[i + ((j - i) & 3) * 4];
		}
	}

	static void AES_InvMixColumns(AESBlock* block)
	{
		uint32_t* pB = (uint32_t*) block;
		for (size_t i = 0; i < 4; ++i)
		{
			uint32_t copy = pB[i];
			uint8_t* p    = (uint8_t*) &pB[i];
			uint8_t* c    = (uint8_t*) &copy;
			p[0]          = AES_XTimes<0x0E>(c[0]) ^ AES_XTimes<0x0B>(c[1]) ^ AES_XTimes<0x0D>(c[2]) ^ AES_XTimes<0x09>(c[3]);
			p[1]          = AES_XTimes<0x0E>(c[1]) ^ AES_XTimes<0x0B>(c[2]) ^ AES_XTimes<0x0D>(c[3]) ^ AES_XTimes<0x09>(c[0]);
			p[2]          = AES_XTimes<0x0E>(c[2]) ^ AES_XTimes<0x0B>(c[3]) ^ AES_XTimes<0x0D>(c[0]) ^ AES_XTimes<0x09>(c[1]);
			p[3]          = AES_XTimes<0x0E>(c[3]) ^ AES_XTimes<0x0B>(c[0]) ^ AES_XTimes<0x0D>(c[1]) ^ AES_XTimes<0x09>(c[2]);
		}
	}

	static void AES_BlockCipher(AESState* state, AESBlock* block)
	{
		AES_AddRoundKey(block, &state->Keys[0]);
		for (size_t round = 1; round < state->Nr; ++round)
		{
			AES_SBox128(block);
			AES_ShiftRows(block);
			AES_MixColumns(block);
			AES_AddRoundKey(block, &state->Keys[round]);
		}
		AES_SBox128(block);
		AES_ShiftRows(block);
		AES_AddRoundKey(block, &state->Keys[state->Nr]);
	}

	static void AES_InvBlockCipher(AESState* state, AESBlock* block)
	{
		AES_AddRoundKey(block, &state->Keys[state->Nr]);
		for (size_t round = state->Nr; round > 1; --round)
		{
			AES_InvShiftRows(block);
			AES_InvSBox128(block);
			AES_AddRoundKey(block, &state->Keys[round - 1]);
			AES_InvMixColumns(block);
		}
		AES_InvShiftRows(block);
		AES_InvSBox128(block);
		AES_AddRoundKey(block, &state->Keys[0]);
	}

	static void AES_KeyExpansion(AESState* state, const void* key, size_t keySize)
	{
		static constexpr uint32_t Rcon[] = { 0x0000'0000, 0x0000'0001, 0x0000'0002, 0x0000'0004, 0x0000'0008, 0x0000'0010, 0x0000'0020, 0x0000'0040, 0x0000'0080, 0x0000'001B, 0x0000'0036 };

		size_t numKeys = state->Nr + 1;
		memcpy(state->Keys, key, keySize);
		switch (state->Nk)
		{
		case 4:
			for (size_t i = 1; i < numKeys; ++i)
			{
				auto&    ckey = state->Keys[i];
				uint32_t last = state->Keys[i - 1].Words[3];
				ckey.Words[0] = state->Keys[i - 1].Words[0] ^ (AES_SBox32(std::rotr(last, 8)) ^ Rcon[i]);
				ckey.Words[1] = state->Keys[i - 1].Words[1] ^ ckey.Words[0];
				ckey.Words[2] = state->Keys[i - 1].Words[2] ^ ckey.Words[1];
				ckey.Words[3] = state->Keys[i - 1].Words[3] ^ ckey.Words[2];
			}
			break;
		case 6:
			for (size_t i = 6; i < numKeys * 4; ++i)
			{
				size_t   pI   = i - 1;
				uint32_t temp = state->Keys[pI >> 2].Words[pI & 3];
				if ((i % 6) == 0)
					temp = AES_SBox32(std::rotr(temp, 8)) ^ Rcon[i / 6];
				state->Keys[i >> 2].Words[i & 3] = state->Keys[(i - 6) >> 2].Words[(i - 6) & 3] ^ temp;
			}
			break;
		case 8:
			for (size_t i = 2; i < numKeys; ++i)
			{
				auto&    ckey = state->Keys[i];
				uint32_t last = state->Keys[i - 1].Words[3];
				ckey.Words[0] = state->Keys[i - 2].Words[0] ^ ((i & 1) == 0 ? AES_SBox32(std::rotr(last, 8)) ^ Rcon[i >> 1] : AES_SBox32(last));
				ckey.Words[1] = state->Keys[i - 2].Words[1] ^ ckey.Words[0];
				ckey.Words[2] = state->Keys[i - 2].Words[2] ^ ckey.Words[1];
				ckey.Words[3] = state->Keys[i - 2].Words[3] ^ ckey.Words[2];
			}
			break;
		}
	}

	bool AES_EncryptSize(size_t dataSize, size_t* encryptedDataSize)
	{
		if (!encryptedDataSize)
			return false;
		*encryptedDataSize = (dataSize + 31) & ~0xFULL;
		return true;
	}

	bool AES_DecryptSize(size_t dataSize, size_t* decryptedDataSize)
	{
		if (!decryptedDataSize)
			return false;
		*decryptedDataSize = (dataSize + 15) & ~0xFULL;
		return true;
	}

	bool AES_ECB_Init(void** state, const void* key, size_t keySize)
	{
		if (!state || !key)
			return false;
		if (keySize != 16 && keySize != 24 && keySize != 32)
			return false;

		AESState* aesState = new AESState();
		memset(&aesState->CBCIV, 0, sizeof(aesState->CBCIV));
		memset(aesState->Keys, 0, sizeof(aesState->Keys));
		aesState->BCM           = EBCM::ECB;
		aesState->Nk            = (uint8_t) (keySize / 4);
		aesState->Nr            = aesState->Nk + 6;
		aesState->TempBlockUsed = 0;
		aesState->Count         = 0;
		AES_KeyExpansion(aesState, key, keySize);
		*state = aesState;
		return true;
	}

	bool AES_CBC_Init(void** state, const void* key, size_t keySize, const void* iv, size_t ivSize)
	{
		if (!state || !key)
			return false;
		if (keySize != 16 && keySize != 24 && keySize != 32 && ivSize != 16)
			return false;

		AESState* aesState = new AESState();
		memcpy(&aesState->CBCIV, iv, sizeof(aesState->CBCIV));
		memset(aesState->Keys, 0, sizeof(aesState->Keys));
		aesState->BCM           = EBCM::CBC;
		aesState->Nk            = (uint8_t) (keySize / 4);
		aesState->Nr            = aesState->Nk + 6;
		aesState->TempBlockUsed = 0;
		aesState->Count         = 0;
		AES_KeyExpansion(aesState, key, keySize);
		*state = aesState;
		return true;
	}

	bool AES_ECB_Reset(void* state, const void* key, size_t keySize)
	{
		if (!state || !key)
			return false;
		if (keySize != 16 && keySize != 24 && keySize != 32)
			return false;

		auto aesState = (AESState*) state;
		memset(&aesState->CBCIV, 0, sizeof(aesState->CBCIV));
		memset(aesState->Keys, 0, sizeof(aesState->Keys));
		aesState->BCM           = EBCM::ECB;
		aesState->Nk            = (uint8_t) (keySize / 4);
		aesState->Nr            = aesState->Nk + 6;
		aesState->TempBlockUsed = 0;
		aesState->Count         = 0;
		AES_KeyExpansion(aesState, key, keySize);
		return true;
	}

	bool AES_CBC_Reset(void* state, const void* key, size_t keySize, const void* iv, size_t ivSize)
	{
		if (!state || !key)
			return false;
		if (keySize != 16 && keySize != 24 && keySize != 32 && ivSize != 16)
			return false;

		auto aesState = (AESState*) state;
		memcpy(&aesState->CBCIV, iv, sizeof(aesState->CBCIV));
		memset(aesState->Keys, 0, sizeof(aesState->Keys));
		aesState->BCM           = EBCM::CBC;
		aesState->Nk            = (uint8_t) (keySize / 4);
		aesState->Nr            = aesState->Nk + 6;
		aesState->TempBlockUsed = 0;
		aesState->Count         = 0;
		AES_KeyExpansion(aesState, key, keySize);
		return true;
	}

	bool AES_Destroy(void* state)
	{
		if (!state)
			return false;
		delete (AESState*) state;
		return true;
	}

	bool AES_EncryptData(void* state, const void* data, size_t dataSize, void* encryptedData, ssize_t* encryptedDataSize)
	{
		if (!state || !data || !encryptedData || !encryptedDataSize)
			return false;

		auto aesState = (AESState*) state;

		size_t requiredOutputSize = (aesState->TempBlockUsed + dataSize) & ~0xFULL;
		if (*encryptedDataSize < requiredOutputSize)
		{
			*encryptedDataSize = requiredOutputSize;
			return false;
		}

		if (dataSize < 16 - aesState->TempBlockUsed)
		{
			memcpy((uint8_t*) &aesState->TempBlock + aesState->TempBlockUsed, data, dataSize);
			aesState->TempBlockUsed += (uint8_t) dataSize;
			*encryptedDataSize       = 0;
			return true;
		}

		AESBlock block;
		memcpy(&block, &aesState->TempBlock, aesState->TempBlockUsed);
		memcpy((uint8_t*) &block + aesState->TempBlockUsed, data, 16 - aesState->TempBlockUsed);
		size_t offset = 16 - aesState->TempBlockUsed;
		if (aesState->BCM == EBCM::CBC)
			AES_AddRoundKey(&block, &aesState->CBCIV);
		AES_BlockCipher(aesState, &block);
		memcpy(encryptedData, &block, 16);
		if (aesState->BCM == EBCM::CBC)
			memcpy(&aesState->CBCIV, &block, 16);
		aesState->TempBlockUsed = 0;

		size_t outputOffset = 16;
		while (offset < dataSize)
		{
			size_t end = offset + 16;
			if (end > dataSize)
			{
				memcpy(&aesState->TempBlock, (const uint8_t*) data + offset, dataSize - offset);
				aesState->TempBlockUsed = (uint8_t) (dataSize - offset);
				break;
			}

			memcpy(&block, (const uint8_t*) data + offset, 16);
			if (aesState->BCM == EBCM::CBC)
				AES_AddRoundKey(&block, &aesState->CBCIV);
			AES_BlockCipher(aesState, &block);
			memcpy((uint8_t*) encryptedData + outputOffset, &block, 16);
			outputOffset += 16;
			offset        = end;
			if (aesState->BCM == EBCM::CBC)
				memcpy(&aesState->CBCIV, &block, 16);
		}
		*encryptedDataSize = outputOffset;
		return true;
	}

	bool AES_DecryptData(void* state, const void* data, size_t dataSize, void* decryptedData, ssize_t* decryptedDataSize)
	{
		if (!state || !data || !decryptedData || !decryptedDataSize)
			return false;

		auto aesState = (AESState*) state;

		size_t requiredOutputSize = (aesState->TempBlockUsed + dataSize) & ~0xFULL;
		if (*decryptedDataSize < requiredOutputSize)
		{
			*decryptedDataSize = requiredOutputSize;
			return false;
		}

		if (dataSize < 16 - aesState->TempBlockUsed)
		{
			memcpy((uint8_t*) &aesState->TempBlock + aesState->TempBlockUsed, data, dataSize);
			aesState->TempBlockUsed += (uint8_t) dataSize;
			*decryptedDataSize       = 0;
			return true;
		}

		AESBlock block, iv2;
		memcpy(&block, &aesState->TempBlock, aesState->TempBlockUsed);
		memcpy((uint8_t*) &block + aesState->TempBlockUsed, data, 16 - aesState->TempBlockUsed);
		size_t offset = 16 - aesState->TempBlockUsed;
		if (aesState->BCM == EBCM::CBC)
			memcpy(&iv2, &block, 16);
		AES_InvBlockCipher(aesState, &block);
		if (aesState->BCM == EBCM::CBC)
		{
			AES_AddRoundKey(&block, &aesState->CBCIV);
			memcpy(&aesState->CBCIV, &iv2, 16);
		}
		memcpy(decryptedData, &block, 16);
		aesState->TempBlockUsed = 0;

		size_t outputOffset = 16;
		while (offset < dataSize)
		{
			size_t end = offset + 16;
			if (end > dataSize)
			{
				memcpy(&aesState->TempBlock, (const uint8_t*) data + offset, dataSize - offset);
				aesState->TempBlockUsed = (uint8_t) (dataSize - offset);
				break;
			}

			memcpy(&block, (const uint8_t*) data + offset, 16);
			if (aesState->BCM == EBCM::CBC)
				memcpy(&iv2, &block, 16);
			AES_InvBlockCipher(aesState, &block);
			if (aesState->BCM == EBCM::CBC)
			{
				AES_AddRoundKey(&block, &aesState->CBCIV);
				memcpy(&aesState->CBCIV, &iv2, 16);
			}
			memcpy((uint8_t*) decryptedData + outputOffset, &block, 16);
			outputOffset += 16;
			offset        = end;
		}
		*decryptedDataSize = outputOffset;
		return true;
	}

	bool AES_EncryptFinal(void* state, const void* data, size_t dataSize, void* encryptedData, ssize_t* encryptedDataSize)
	{
		if (!state || !encryptedData || !encryptedDataSize || (dataSize > 0 && !data))
			return false;

		auto   aesState           = (AESState*) state;
		size_t requiredOutputSize = ((aesState->TempBlockUsed + dataSize + 16) & ~0xFULL);
		if (*encryptedDataSize < requiredOutputSize)
		{
			*encryptedDataSize = requiredOutputSize;
			return false;
		}

		if (dataSize > 0)
		{
			if (!AES_EncryptData(state, data, dataSize, encryptedData, encryptedDataSize))
				return false;
		}
		else
		{
			*encryptedDataSize = 0;
		}

		memset((uint8_t*) &aesState->TempBlock + aesState->TempBlockUsed, 16 - aesState->TempBlockUsed, 16 - aesState->TempBlockUsed);
		if (aesState->BCM == EBCM::CBC)
			AES_AddRoundKey(&aesState->TempBlock, &aesState->CBCIV);
		AES_BlockCipher(aesState, &aesState->TempBlock);
		memcpy((uint8_t*) encryptedData + *encryptedDataSize, &aesState->TempBlock, 16);
		*encryptedDataSize += 16;
		return true;
	}

	bool AES_DecryptFinal(void* state, const void* data, size_t dataSize, void* decryptedData, ssize_t* decryptedDataSize)
	{
		if (!state || !decryptedData || !decryptedDataSize || (dataSize > 0 && !data))
			return false;

		auto aesState = (AESState*) state;
		if (dataSize > 0 && !AES_DecryptData(state, data, dataSize, decryptedData, decryptedDataSize))
			return false;

		*decryptedDataSize -= aesState->TempBlock.Words[3] >> 24;
		return true;
	}
} // namespace Crypto