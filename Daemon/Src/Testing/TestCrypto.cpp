#include "TestCrypto.h"

#include <Crypto/Crypto.h>
#include <Testing/Testing.h>

/*
 * SHA Test Vectors
 * "abc": 3
 *	SHA1:     A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
 *	SHA2-224: 23097D22 3405D822 8642A477 BDA255B3 2AADBCE4 BDA0B3F7 E36C9DA7
 *	SHA2-256: BA7816BF 8F01CFEA 414140DE 5DAE2223 B00361A3 96177A9C B410FF61 F20015AD
 *	SHA2-384: CB00753F45A35E8B B5A03D699AC65007 272C32AB0EDED163 1A8B605A43FF5BED 8086072BA1E7CC23 58BAECA134C825A7
 *	SHA2-512: DDAF35A193617ABA CC417349AE204131 12E6FA4E89A97EA2 0A9EEEE64B55D39A 2192992A274FC1A8 36BA3C23A3FEEBBD 454D4423643CE80E 2A9AC94FA54CA49F
 *	SHA3-224: E642824C3F8CF24A D09234EE7D3C766F C9A3A5168D0C94AD 73B46FDF
 *	SHA3-256: 3A985DA74FE225B2 045C172D6BD390BD 855F086E3E9D525B 46BFE24511431532
 *	SHA3-384: EC01498288516FC9 26459F58E2C6AD8D F9B473CB0FC08C25 96DA7CF0E49BE4B2 98D88CEA927AC7F5 39F1EDF228376D25
 *	SHA3-512: B751850B1A57168A 5693CD924B6B096E 08F621827444F70D 884F5D0240D2712E 10E116E9192AF3C9 1A7EC57647E39340 57340B4CF408D5A5 6592F8274EEC53F0
 * "": 0
 *	SHA1:     DA39A3EE 5E6B4B0D 3255BFEF 95601890 AFD80709
 *	SHA2-224: D14A028C 2A3A2BC9 476102BB 288234C4 15A2B01F 828EA62A C5B3E42F
 *	SHA2-256: E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855
 *	SHA2-384: 38B060A751AC9638 4CD9327EB1B1E36A 21FDB71114BE0743 4C0CC7BF63F6E1DA 274EDEBFE76F65FB D51AD2F14898B95B
 *	SHA2-512: CF83E1357EEFB8BD F1542850D66D8007 D620E4050B5715DC 83F4A921D36CE9CE 47D0D13C5D85F2B0 FF8318D2877EEC2F 63B931BD47417A81 A538327AF927DA3E
 *	SHA3-224: 6B4E03423667DBB7 3B6E15454F0EB1AB D4597F9A1B078E3F 5B5A6BC7
 *	SHA3-256: A7FFC6F8BF1ED766 51C14756A061D662 F580FF4DE43B49FA 82D80A4B80F8434A
 *	SHA3-384: 0C63A75B845E4F7D 01107D852E4C2485 C51A50AAAA94FC61 995E71BBEE983A2A C3713831264ADB47 FB6BD1E058D5F004
 *	SHA3-512: A69F73CCA23A9AC5 C8B567DC185A756E 97C982164FE25859 E0D1DCC1475C80A6 15B2123AF1F5F94C 11E3E9402C3AC558 F500199D95B6D3E3 01758586281DCD26
 * "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq": 56
 *	SHA1:     84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
 *	SHA2-224: 75388B16 512776CC 5DBA5DA1 FD890150 B0C6455C B4F58B19 52522525
 *	SHA2-256: 248D6A61 D20638B8 E5C02693 0C3E6039 A33CE459 64FF2167 F6ECEDD4 19DB06C1
 *	SHA2-384: 3391FDDDFC8DC739 3707A65B1B470939 7CF8B1D162AF05AB FE8F450DE5F36BC6 B0455A8520BC4E6F 5FE95B1FE3C8452B
 *	SHA2-512: 204A8FC6DDA82F0A 0CED7BEB8E08A416 57C16EF468B228A8 279BE331A703C335 96FD15C13B1B07F9 AA1D3BEA57789CA0 31AD85C7A71DD703 54EC631238CA3445
 *	SHA3-224: 8A24108B154ADA21 C9FD5574494479BA 5C7E7AB76EF264EA D0FCCE33
 *	SHA3-256: 41C0DBA2A9D62408 49100376A8235E2C 82E1B9998A999E21 DB32DD97496D3376
 *	SHA3-384: 991C665755EB3A4B 6BBDFB75C78A492E 8C56A22C5C4D7E42 9BFDBC32B9D4AD5A A04A1F076E62FEA1 9EEF51ACD0657C22
 *	SHA3-512: 04A371E84ECFB5B8 B77CB48610FCA818 2DD457CE6F326A0F D3D7EC2F1E91636D EE691FBE0C985302 BA1B0D8DC78C0863 46B533B49C030D99 A27DAF1139D6E75E
 * "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu": 112
 *	SHA1:     A49B2446 A02C645B F419F995 B6709125 3A04A259
 *	SHA2-224: C97CA9A5 59850CE9 7A04A96D EF6D99A9 E0E0E2AB 14E6B8DF 265FC0B3
 *	SHA2-256: CF5B16A7 78AF8380 036CE59E 7B049237 0B249B11 E8F07A51 AFAC4503 7AFEE9D1
 *	SHA2-384: 09330C33F71147E8 3D192FC782CD1B47 53111B173B3B05D2 2FA08086E3B0F712 FCC7C71A557E2DB9 66C3E9FA91746039
 *	SHA2-512: 8E959B75DAE313DA 8CF4F72814FC143F 8F7779C6EB9F7FA1 7299AEADB6889018 501D289E4900F7E4 331B99DEC4B5433A C7D329EEB6DD2654 5E96E55B874BE909
 *	SHA3-224: 543E6868E1666C1A 643630DF77367AE5 A62A85070A51C14C BF665CBC
 *	SHA3-256: 916F6061FE879741 CA6469B43971DFDB 28B1A32DC36CB325 4E812BE27AAD1D18
 *	SHA3-384: 79407D3B5916B59C 3E30B09822974791 C313FB9ECC849E40 6F23592D04F625DC 8C709B98B43B3852 B337216179AA7FC7
 *	SHA3-512: AFEBB2EF542E6579 C50CAD06D2E578F9 F8DD6881D7DC824D 26360FEEBF18A4FA 73E3261122948EFC FD492E74E82E2189 ED0FB440D187F382 270CB455F21DD185
 * 1 million 'a':
 *	SHA1:     34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
 *	SHA2-224: 20794655 980C91D8 BBB4C1EA 97618A4B F03F4258 1948B2EE 4EE7AD67
 *	SHA2-256: CDC76E5C 9914FB92 81A1C7E2 84D73E67 F1809A48 A497200E 046D39CC C7112CD0
 *	SHA2-384: 9D0E1809716474CB 086E834E310A4A1C ED149E9C00F24852 7972CEC5704C2A5B 07B8B3DC38ECC4EB AE97DDD87F3D8985
 *	SHA2-512: E718483D0CE76964 4E2E42C7BC15B463 8E1F98B13B204428 5632A803AFA973EB DE0FF244877EA60A 4CB0432CE577C31B EB009C5C2C49AA2E 4EADB217AD8CC09B
 *	SHA3-224: D69335B93325192E 516A912E6D19A15C B51C6ED5C15243E7 A7FD653C
 *	SHA3-256: 5C8875AE474A3634 BA4FD55EC85BFFD6 61F32ACA75C6D699 D0CDCB6C115891C1
 *	SHA3-384: EEE9E24D78C18553 37983451DF97C8AD 9EEDF256C6334F8E 948D252D5E0E7684 7AA0774DDB90A842 190D2C558B4B8340
 *	SHA3-512: 3C3A876DA14034AB 60627C077BB98F7E 120A2A5370212DFF B3385A18D4F38859 ED311D0A9D5141CE 9CC5C66EE689B266 A8AA18ACE8282A0E 0DB596C90B0A7B87
 * "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno" repeated 16777216 times:
 *	SHA1:     7789F0C9 EF7BFC40 D9331114 3DFBE69E 2017F592
 *	SHA2-224: B5989713 CA4FE47A 009F8621 980B34E6 D63ED306 3B2A0A2C 867D8A85
 *	SHA2-256: 50E72A0E 26442FE2 552DC393 8AC58658 228C0CBF B1D2CA87 2AE43526 6FCD055E
 *	SHA2-384: 5441235CC0235341 ED806A64FB354742 B5E5C02A3C5CB71B 5F63FB793458D8FD AE599C8CD8884943 C04F11B31B89F023
 *	SHA2-512: B47C933421EA2DB1 49AD6E10FCE6C7F9 3D0752380180FFD7 F4629A712134831D 77BE6091B819ED35 2C2967A2E2D4FA50 50723C9630691F1A 05A7281DBE6C1086
 *	SHA3-224: C6D66E77AE289566 AFB2CE39277752D6 DA2A3C46010F1E0A 0970FF60
 *	SHA3-256: ECBBC42CBF296603 ACB2C6BC0410EF43 78BAFB24B710357F 12DF607758B33E2B
 *	SHA3-384: A04296F4FCAAE148 71BB5AD33E28DCF6 9238B04204D9941B 8782E816D014BCB7 540E4AF54F30D578 F1A1CA2930847A12
 *	SHA3-512: 235FFD53504EF836 A1342B488F483B39 6EABBFE642CF78EE 0D31FEEC788B23D0 D18D5C339550DD59 58A500D4B95363DA 1B5FA18AFFC1BAB2 292DC63B7D85097C
 */

namespace Testing
{
	template <Crypto::ESHAFunction Func>
	static void TestSHA_1()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22, 0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3, 0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7, 0xE3, 0x6C, 0x9D, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA, 0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23, 0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C, 0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B, 0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07, 0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63, 0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED, 0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23, 0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA, 0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31, 0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2, 0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A, 0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8, 0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD, 0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E, 0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F, 0xE6, 0x42, 0x82, 0x4C, 0x3F, 0x8C, 0xF2, 0x4A, 0xD0, 0x92, 0x34, 0xEE, 0x7D, 0x3C, 0x76, 0x6F, 0xC9, 0xA3, 0xA5, 0x16, 0x8D, 0x0C, 0x94, 0xAD, 0x73, 0xB4, 0x6F, 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x98, 0x5D, 0xA7, 0x4F, 0xE2, 0x25, 0xB2, 0x04, 0x5C, 0x17, 0x2D, 0x6B, 0xD3, 0x90, 0xBD, 0x85, 0x5F, 0x08, 0x6E, 0x3E, 0x9D, 0x52, 0x5B, 0x46, 0xBF, 0xE2, 0x45, 0x11, 0x43, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x01, 0x49, 0x82, 0x88, 0x51, 0x6F, 0xC9, 0x26, 0x45, 0x9F, 0x58, 0xE2, 0xC6, 0xAD, 0x8D, 0xF9, 0xB4, 0x73, 0xCB, 0x0F, 0xC0, 0x8C, 0x25, 0x96, 0xDA, 0x7C, 0xF0, 0xE4, 0x9B, 0xE4, 0xB2, 0x98, 0xD8, 0x8C, 0xEA, 0x92, 0x7A, 0xC7, 0xF5, 0x39, 0xF1, 0xED, 0xF2, 0x28, 0x37, 0x6D, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x51, 0x85, 0x0B, 0x1A, 0x57, 0x16, 0x8A, 0x56, 0x93, 0xCD, 0x92, 0x4B, 0x6B, 0x09, 0x6E, 0x08, 0xF6, 0x21, 0x82, 0x74, 0x44, 0xF7, 0x0D, 0x88, 0x4F, 0x5D, 0x02, 0x40, 0xD2, 0x71, 0x2E, 0x10, 0xE1, 0x16, 0xE9, 0x19, 0x2A, 0xF3, 0xC9, 0x1A, 0x7E, 0xC5, 0x76, 0x47, 0xE3, 0x93, 0x40, 0x57, 0x34, 0x0B, 0x4C, 0xF4, 0x08, 0xD5, 0xA5, 0x65, 0x92, 0xF8, 0x27, 0x4E, 0xEC, 0x53, 0xF0 };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		result = result && Crypto::SHA_Data(state, "abc", 3);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	template <Crypto::ESHAFunction Func>
	static void TestSHA_2()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0xDA, 0x39, 0xA3, 0xEE, 0x5E, 0x6B, 0x4B, 0x0D, 0x32, 0x55, 0xBF, 0xEF, 0x95, 0x60, 0x18, 0x90, 0xAF, 0xD8, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x4A, 0x02, 0x8C, 0x2A, 0x3A, 0x2B, 0xC9, 0x47, 0x61, 0x02, 0xBB, 0x28, 0x82, 0x34, 0xC4, 0x15, 0xA2, 0xB0, 0x1F, 0x82, 0x8E, 0xA6, 0x2A, 0xC5, 0xB3, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xB0, 0xC4, 0x42, 0x98, 0xFC, 0x1C, 0x14, 0x9A, 0xFB, 0xF4, 0xC8, 0x99, 0x6F, 0xB9, 0x24, 0x27, 0xAE, 0x41, 0xE4, 0x64, 0x9B, 0x93, 0x4C, 0xA4, 0x95, 0x99, 0x1B, 0x78, 0x52, 0xB8, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xB0, 0x60, 0xA7, 0x51, 0xAC, 0x96, 0x38, 0x4C, 0xD9, 0x32, 0x7E, 0xB1, 0xB1, 0xE3, 0x6A, 0x21, 0xFD, 0xB7, 0x11, 0x14, 0xBE, 0x07, 0x43, 0x4C, 0x0C, 0xC7, 0xBF, 0x63, 0xF6, 0xE1, 0xDA, 0x27, 0x4E, 0xDE, 0xBF, 0xE7, 0x6F, 0x65, 0xFB, 0xD5, 0x1A, 0xD2, 0xF1, 0x48, 0x98, 0xB9, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCF, 0x83, 0xE1, 0x35, 0x7E, 0xEF, 0xB8, 0xBD, 0xF1, 0x54, 0x28, 0x50, 0xD6, 0x6D, 0x80, 0x07, 0xD6, 0x20, 0xE4, 0x05, 0x0B, 0x57, 0x15, 0xDC, 0x83, 0xF4, 0xA9, 0x21, 0xD3, 0x6C, 0xE9, 0xCE, 0x47, 0xD0, 0xD1, 0x3C, 0x5D, 0x85, 0xF2, 0xB0, 0xFF, 0x83, 0x18, 0xD2, 0x87, 0x7E, 0xEC, 0x2F, 0x63, 0xB9, 0x31, 0xBD, 0x47, 0x41, 0x7A, 0x81, 0xA5, 0x38, 0x32, 0x7A, 0xF9, 0x27, 0xDA, 0x3E, 0x6B, 0x4E, 0x03, 0x42, 0x36, 0x67, 0xDB, 0xB7, 0x3B, 0x6E, 0x15, 0x45, 0x4F, 0x0E, 0xB1, 0xAB, 0xD4, 0x59, 0x7F, 0x9A, 0x1B, 0x07, 0x8E, 0x3F, 0x5B, 0x5A, 0x6B, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xC6, 0xF8, 0xBF, 0x1E, 0xD7, 0x66, 0x51, 0xC1, 0x47, 0x56, 0xA0, 0x61, 0xD6, 0x62, 0xF5, 0x80, 0xFF, 0x4D, 0xE4, 0x3B, 0x49, 0xFA, 0x82, 0xD8, 0x0A, 0x4B, 0x80, 0xF8, 0x43, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x63, 0xA7, 0x5B, 0x84, 0x5E, 0x4F, 0x7D, 0x01, 0x10, 0x7D, 0x85, 0x2E, 0x4C, 0x24, 0x85, 0xC5, 0x1A, 0x50, 0xAA, 0xAA, 0x94, 0xFC, 0x61, 0x99, 0x5E, 0x71, 0xBB, 0xEE, 0x98, 0x3A, 0x2A, 0xC3, 0x71, 0x38, 0x31, 0x26, 0x4A, 0xDB, 0x47, 0xFB, 0x6B, 0xD1, 0xE0, 0x58, 0xD5, 0xF0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x9F, 0x73, 0xCC, 0xA2, 0x3A, 0x9A, 0xC5, 0xC8, 0xB5, 0x67, 0xDC, 0x18, 0x5A, 0x75, 0x6E, 0x97, 0xC9, 0x82, 0x16, 0x4F, 0xE2, 0x58, 0x59, 0xE0, 0xD1, 0xDC, 0xC1, 0x47, 0x5C, 0x80, 0xA6, 0x15, 0xB2, 0x12, 0x3A, 0xF1, 0xF5, 0xF9, 0x4C, 0x11, 0xE3, 0xE9, 0x40, 0x2C, 0x3A, 0xC5, 0x58, 0xF5, 0x00, 0x19, 0x9D, 0x95, 0xB6, 0xD3, 0xE3, 0x01, 0x75, 0x85, 0x86, 0x28, 0x1D, 0xCD, 0x26 };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		result = result && Crypto::SHA_Data(state, "", 0);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	template <Crypto::ESHAFunction Func>
	static void TestSHA_3()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC, 0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50, 0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19, 0x52, 0x52, 0x25, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8, 0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39, 0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67, 0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x91, 0xFD, 0xDD, 0xFC, 0x8D, 0xC7, 0x39, 0x37, 0x07, 0xA6, 0x5B, 0x1B, 0x47, 0x09, 0x39, 0x7C, 0xF8, 0xB1, 0xD1, 0x62, 0xAF, 0x05, 0xAB, 0xFE, 0x8F, 0x45, 0x0D, 0xE5, 0xF3, 0x6B, 0xC6, 0xB0, 0x45, 0x5A, 0x85, 0x20, 0xBC, 0x4E, 0x6F, 0x5F, 0xE9, 0x5B, 0x1F, 0xE3, 0xC8, 0x45, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4A, 0x8F, 0xC6, 0xDD, 0xA8, 0x2F, 0x0A, 0x0C, 0xED, 0x7B, 0xEB, 0x8E, 0x08, 0xA4, 0x16, 0x57, 0xC1, 0x6E, 0xF4, 0x68, 0xB2, 0x28, 0xA8, 0x27, 0x9B, 0xE3, 0x31, 0xA7, 0x03, 0xC3, 0x35, 0x96, 0xFD, 0x15, 0xC1, 0x3B, 0x1B, 0x07, 0xF9, 0xAA, 0x1D, 0x3B, 0xEA, 0x57, 0x78, 0x9C, 0xA0, 0x31, 0xAD, 0x85, 0xC7, 0xA7, 0x1D, 0xD7, 0x03, 0x54, 0xEC, 0x63, 0x12, 0x38, 0xCA, 0x34, 0x45, 0x8A, 0x24, 0x10, 0x8B, 0x15, 0x4A, 0xDA, 0x21, 0xC9, 0xFD, 0x55, 0x74, 0x49, 0x44, 0x79, 0xBA, 0x5C, 0x7E, 0x7A, 0xB7, 0x6E, 0xF2, 0x64, 0xEA, 0xD0, 0xFC, 0xCE, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xC0, 0xDB, 0xA2, 0xA9, 0xD6, 0x24, 0x08, 0x49, 0x10, 0x03, 0x76, 0xA8, 0x23, 0x5E, 0x2C, 0x82, 0xE1, 0xB9, 0x99, 0x8A, 0x99, 0x9E, 0x21, 0xDB, 0x32, 0xDD, 0x97, 0x49, 0x6D, 0x33, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x1C, 0x66, 0x57, 0x55, 0xEB, 0x3A, 0x4B, 0x6B, 0xBD, 0xFB, 0x75, 0xC7, 0x8A, 0x49, 0x2E, 0x8C, 0x56, 0xA2, 0x2C, 0x5C, 0x4D, 0x7E, 0x42, 0x9B, 0xFD, 0xBC, 0x32, 0xB9, 0xD4, 0xAD, 0x5A, 0xA0, 0x4A, 0x1F, 0x07, 0x6E, 0x62, 0xFE, 0xA1, 0x9E, 0xEF, 0x51, 0xAC, 0xD0, 0x65, 0x7C, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA3, 0x71, 0xE8, 0x4E, 0xCF, 0xB5, 0xB8, 0xB7, 0x7C, 0xB4, 0x86, 0x10, 0xFC, 0xA8, 0x18, 0x2D, 0xD4, 0x57, 0xCE, 0x6F, 0x32, 0x6A, 0x0F, 0xD3, 0xD7, 0xEC, 0x2F, 0x1E, 0x91, 0x63, 0x6D, 0xEE, 0x69, 0x1F, 0xBE, 0x0C, 0x98, 0x53, 0x02, 0xBA, 0x1B, 0x0D, 0x8D, 0xC7, 0x8C, 0x08, 0x63, 0x46, 0xB5, 0x33, 0xB4, 0x9C, 0x03, 0x0D, 0x99, 0xA2, 0x7D, 0xAF, 0x11, 0x39, 0xD6, 0xE7, 0x5E };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		result = result && Crypto::SHA_Data(state, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	template <Crypto::ESHAFunction Func>
	static void TestSHA_4()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0xA4, 0x9B, 0x24, 0x46, 0xA0, 0x2C, 0x64, 0x5B, 0xF4, 0x19, 0xF9, 0x95, 0xB6, 0x70, 0x91, 0x25, 0x3A, 0x04, 0xA2, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x7C, 0xA9, 0xA5, 0x59, 0x85, 0x0C, 0xE9, 0x7A, 0x04, 0xA9, 0x6D, 0xEF, 0x6D, 0x99, 0xA9, 0xE0, 0xE0, 0xE2, 0xAB, 0x14, 0xE6, 0xB8, 0xDF, 0x26, 0x5F, 0xC0, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCF, 0x5B, 0x16, 0xA7, 0x78, 0xAF, 0x83, 0x80, 0x03, 0x6C, 0xE5, 0x9E, 0x7B, 0x04, 0x92, 0x37, 0x0B, 0x24, 0x9B, 0x11, 0xE8, 0xF0, 0x7A, 0x51, 0xAF, 0xAC, 0x45, 0x03, 0x7A, 0xFE, 0xE9, 0xD1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x33, 0x0C, 0x33, 0xF7, 0x11, 0x47, 0xE8, 0x3D, 0x19, 0x2F, 0xC7, 0x82, 0xCD, 0x1B, 0x47, 0x53, 0x11, 0x1B, 0x17, 0x3B, 0x3B, 0x05, 0xD2, 0x2F, 0xA0, 0x80, 0x86, 0xE3, 0xB0, 0xF7, 0x12, 0xFC, 0xC7, 0xC7, 0x1A, 0x55, 0x7E, 0x2D, 0xB9, 0x66, 0xC3, 0xE9, 0xFA, 0x91, 0x74, 0x60, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA, 0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F, 0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1, 0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18, 0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4, 0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A, 0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54, 0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09, 0x54, 0x3E, 0x68, 0x68, 0xE1, 0x66, 0x6C, 0x1A, 0x64, 0x36, 0x30, 0xDF, 0x77, 0x36, 0x7A, 0xE5, 0xA6, 0x2A, 0x85, 0x07, 0x0A, 0x51, 0xC1, 0x4C, 0xBF, 0x66, 0x5C, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0x6F, 0x60, 0x61, 0xFE, 0x87, 0x97, 0x41, 0xCA, 0x64, 0x69, 0xB4, 0x39, 0x71, 0xDF, 0xDB, 0x28, 0xB1, 0xA3, 0x2D, 0xC3, 0x6C, 0xB3, 0x25, 0x4E, 0x81, 0x2B, 0xE2, 0x7A, 0xAD, 0x1D, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x40, 0x7D, 0x3B, 0x59, 0x16, 0xB5, 0x9C, 0x3E, 0x30, 0xB0, 0x98, 0x22, 0x97, 0x47, 0x91, 0xC3, 0x13, 0xFB, 0x9E, 0xCC, 0x84, 0x9E, 0x40, 0x6F, 0x23, 0x59, 0x2D, 0x04, 0xF6, 0x25, 0xDC, 0x8C, 0x70, 0x9B, 0x98, 0xB4, 0x3B, 0x38, 0x52, 0xB3, 0x37, 0x21, 0x61, 0x79, 0xAA, 0x7F, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0xEB, 0xB2, 0xEF, 0x54, 0x2E, 0x65, 0x79, 0xC5, 0x0C, 0xAD, 0x06, 0xD2, 0xE5, 0x78, 0xF9, 0xF8, 0xDD, 0x68, 0x81, 0xD7, 0xDC, 0x82, 0x4D, 0x26, 0x36, 0x0F, 0xEE, 0xBF, 0x18, 0xA4, 0xFA, 0x73, 0xE3, 0x26, 0x11, 0x22, 0x94, 0x8E, 0xFC, 0xFD, 0x49, 0x2E, 0x74, 0xE8, 0x2E, 0x21, 0x89, 0xED, 0x0F, 0xB4, 0x40, 0xD1, 0x87, 0xF3, 0x82, 0x27, 0x0C, 0xB4, 0x55, 0xF2, 0x1D, 0xD1, 0x85 };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		result = result && Crypto::SHA_Data(state, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	template <Crypto::ESHAFunction Func>
	static void TestSHA_5()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E, 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8, 0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B, 0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE, 0x4E, 0xE7, 0xAD, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92, 0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67, 0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E, 0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D, 0x0E, 0x18, 0x09, 0x71, 0x64, 0x74, 0xCB, 0x08, 0x6E, 0x83, 0x4E, 0x31, 0x0A, 0x4A, 0x1C, 0xED, 0x14, 0x9E, 0x9C, 0x00, 0xF2, 0x48, 0x52, 0x79, 0x72, 0xCE, 0xC5, 0x70, 0x4C, 0x2A, 0x5B, 0x07, 0xB8, 0xB3, 0xDC, 0x38, 0xEC, 0xC4, 0xEB, 0xAE, 0x97, 0xDD, 0xD8, 0x7F, 0x3D, 0x89, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x18, 0x48, 0x3D, 0x0C, 0xE7, 0x69, 0x64, 0x4E, 0x2E, 0x42, 0xC7, 0xBC, 0x15, 0xB4, 0x63, 0x8E, 0x1F, 0x98, 0xB1, 0x3B, 0x20, 0x44, 0x28, 0x56, 0x32, 0xA8, 0x03, 0xAF, 0xA9, 0x73, 0xEB, 0xDE, 0x0F, 0xF2, 0x44, 0x87, 0x7E, 0xA6, 0x0A, 0x4C, 0xB0, 0x43, 0x2C, 0xE5, 0x77, 0xC3, 0x1B, 0xEB, 0x00, 0x9C, 0x5C, 0x2C, 0x49, 0xAA, 0x2E, 0x4E, 0xAD, 0xB2, 0x17, 0xAD, 0x8C, 0xC0, 0x9B, 0xD6, 0x93, 0x35, 0xB9, 0x33, 0x25, 0x19, 0x2E, 0x51, 0x6A, 0x91, 0x2E, 0x6D, 0x19, 0xA1, 0x5C, 0xB5, 0x1C, 0x6E, 0xD5, 0xC1, 0x52, 0x43, 0xE7, 0xA7, 0xFD, 0x65, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x88, 0x75, 0xAE, 0x47, 0x4A, 0x36, 0x34, 0xBA, 0x4F, 0xD5, 0x5E, 0xC8, 0x5B, 0xFF, 0xD6, 0x61, 0xF3, 0x2A, 0xCA, 0x75, 0xC6, 0xD6, 0x99, 0xD0, 0xCD, 0xCB, 0x6C, 0x11, 0x58, 0x91, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xE9, 0xE2, 0x4D, 0x78, 0xC1, 0x85, 0x53, 0x37, 0x98, 0x34, 0x51, 0xDF, 0x97, 0xC8, 0xAD, 0x9E, 0xED, 0xF2, 0x56, 0xC6, 0x33, 0x4F, 0x8E, 0x94, 0x8D, 0x25, 0x2D, 0x5E, 0x0E, 0x76, 0x84, 0x7A, 0xA0, 0x77, 0x4D, 0xDB, 0x90, 0xA8, 0x42, 0x19, 0x0D, 0x2C, 0x55, 0x8B, 0x4B, 0x83, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3A, 0x87, 0x6D, 0xA1, 0x40, 0x34, 0xAB, 0x60, 0x62, 0x7C, 0x07, 0x7B, 0xB9, 0x8F, 0x7E, 0x12, 0x0A, 0x2A, 0x53, 0x70, 0x21, 0x2D, 0xFF, 0xB3, 0x38, 0x5A, 0x18, 0xD4, 0xF3, 0x88, 0x59, 0xED, 0x31, 0x1D, 0x0A, 0x9D, 0x51, 0x41, 0xCE, 0x9C, 0xC5, 0xC6, 0x6E, 0xE6, 0x89, 0xB2, 0x66, 0xA8, 0xAA, 0x18, 0xAC, 0xE8, 0x28, 0x2A, 0x0E, 0x0D, 0xB5, 0x96, 0xC9, 0x0B, 0x0A, 0x7B, 0x87 };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		for (size_t i = 0; i < 15625; ++i)
			result = result && Crypto::SHA_Data(state, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 64);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	template <Crypto::ESHAFunction Func>
	static void TestSHA_6()
	{
		static constexpr uint8_t validDigest[64 * 9] = { 0x77, 0x89, 0xF0, 0xC9, 0xEF, 0x7B, 0xFC, 0x40, 0xD9, 0x33, 0x11, 0x14, 0x3D, 0xFB, 0xE6, 0x9E, 0x20, 0x17, 0xF5, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x98, 0x97, 0x13, 0xCA, 0x4F, 0xE4, 0x7A, 0x00, 0x9F, 0x86, 0x21, 0x98, 0x0B, 0x34, 0xE6, 0xD6, 0x3E, 0xD3, 0x06, 0x3B, 0x2A, 0x0A, 0x2C, 0x86, 0x7D, 0x8A, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xE7, 0x2A, 0x0E, 0x26, 0x44, 0x2F, 0xE2, 0x55, 0x2D, 0xC3, 0x93, 0x8A, 0xC5, 0x86, 0x58, 0x22, 0x8C, 0x0C, 0xBF, 0xB1, 0xD2, 0xCA, 0x87, 0x2A, 0xE4, 0x35, 0x26, 0x6F, 0xCD, 0x05, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x41, 0x23, 0x5C, 0xC0, 0x23, 0x53, 0x41, 0xED, 0x80, 0x6A, 0x64, 0xFB, 0x35, 0x47, 0x42, 0xB5, 0xE5, 0xC0, 0x2A, 0x3C, 0x5C, 0xB7, 0x1B, 0x5F, 0x63, 0xFB, 0x79, 0x34, 0x58, 0xD8, 0xFD, 0xAE, 0x59, 0x9C, 0x8C, 0xD8, 0x88, 0x49, 0x43, 0xC0, 0x4F, 0x11, 0xB3, 0x1B, 0x89, 0xF0, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x7C, 0x93, 0x34, 0x21, 0xEA, 0x2D, 0xB1, 0x49, 0xAD, 0x6E, 0x10, 0xFC, 0xE6, 0xC7, 0xF9, 0x3D, 0x07, 0x52, 0x38, 0x01, 0x80, 0xFF, 0xD7, 0xF4, 0x62, 0x9A, 0x71, 0x21, 0x34, 0x83, 0x1D, 0x77, 0xBE, 0x60, 0x91, 0xB8, 0x19, 0xED, 0x35, 0x2C, 0x29, 0x67, 0xA2, 0xE2, 0xD4, 0xFA, 0x50, 0x50, 0x72, 0x3C, 0x96, 0x30, 0x69, 0x1F, 0x1A, 0x05, 0xA7, 0x28, 0x1D, 0xBE, 0x6C, 0x10, 0x86, 0xC6, 0xD6, 0x6E, 0x77, 0xAE, 0x28, 0x95, 0x66, 0xAF, 0xB2, 0xCE, 0x39, 0x27, 0x77, 0x52, 0xD6, 0xDA, 0x2A, 0x3C, 0x46, 0x01, 0x0F, 0x1E, 0x0A, 0x09, 0x70, 0xFF, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xBB, 0xC4, 0x2C, 0xBF, 0x29, 0x66, 0x03, 0xAC, 0xB2, 0xC6, 0xBC, 0x04, 0x10, 0xEF, 0x43, 0x78, 0xBA, 0xFB, 0x24, 0xB7, 0x10, 0x35, 0x7F, 0x12, 0xDF, 0x60, 0x77, 0x58, 0xB3, 0x3E, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x42, 0x96, 0xF4, 0xFC, 0xAA, 0xE1, 0x48, 0x71, 0xBB, 0x5A, 0xD3, 0x3E, 0x28, 0xDC, 0xF6, 0x92, 0x38, 0xB0, 0x42, 0x04, 0xD9, 0x94, 0x1B, 0x87, 0x82, 0xE8, 0x16, 0xD0, 0x14, 0xBC, 0xB7, 0x54, 0x0E, 0x4A, 0xF5, 0x4F, 0x30, 0xD5, 0x78, 0xF1, 0xA1, 0xCA, 0x29, 0x30, 0x84, 0x7A, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x5F, 0xFD, 0x53, 0x50, 0x4E, 0xF8, 0x36, 0xA1, 0x34, 0x2B, 0x48, 0x8F, 0x48, 0x3B, 0x39, 0x6E, 0xAB, 0xBF, 0xE6, 0x42, 0xCF, 0x78, 0xEE, 0x0D, 0x31, 0xFE, 0xEC, 0x78, 0x8B, 0x23, 0xD0, 0xD1, 0x8D, 0x5C, 0x33, 0x95, 0x50, 0xDD, 0x59, 0x58, 0xA5, 0x00, 0xD4, 0xB9, 0x53, 0x63, 0xDA, 0x1B, 0x5F, 0xA1, 0x8A, 0xFF, 0xC1, 0xBA, 0xB2, 0x29, 0x2D, 0xC6, 0x3B, 0x7D, 0x85, 0x09, 0x7C };

		void*   state = nullptr;
		uint8_t digest[64];
		size_t  digestSize = 0;
		bool    result     = Crypto::SHA_Init(&state, Func);
		Crypto::SHA_DigestSize(state, &digestSize);
		for (size_t i = 0; i < 16777216; ++i)
			result = result && Crypto::SHA_Data(state, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno", 64);
		result = result && Crypto::SHA_Final(state, digest, &digestSize);
		Crypto::SHA_Destroy(state);
		Testing::Assert(result && memcmp(digest, validDigest + 64 * (uint32_t) Func, digestSize) == 0);
	}

	static constexpr uint8_t c_AESPlaintext[64] = { 0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A, 0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51, 0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF, 0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10 };
	static constexpr uint8_t c_AES128Key[16]    = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };
	static constexpr uint8_t c_AES192Key[24]    = { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B };
	static constexpr uint8_t c_AES256Key[32]    = { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 };

	static constexpr uint8_t c_AES128ECBCiphertext[64 + 16] = { 0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60, 0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF, 0x97, 0xF5, 0xD3, 0xD5, 0x85, 0x03, 0xB9, 0x69, 0x9D, 0xE7, 0x85, 0x89, 0x5A, 0x96, 0xFD, 0xBA, 0xAF, 0x43, 0xB1, 0xCD, 0x7F, 0x59, 0x8E, 0xCE, 0x23, 0x88, 0x1B, 0x00, 0xE3, 0xED, 0x03, 0x06, 0x88, 0x7B, 0x0C, 0x78, 0x5E, 0x27, 0xE8, 0xAD, 0x3F, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5D, 0xD4, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };
	static constexpr uint8_t c_AES192ECBCiphertext[64 + 16] = { 0xBD, 0x33, 0x4F, 0x1D, 0x6E, 0x45, 0xF2, 0x5F, 0xF7, 0x12, 0xA2, 0x14, 0x57, 0x1F, 0xA5, 0xCC, 0x97, 0x41, 0x04, 0x84, 0x6D, 0x0A, 0xD3, 0xAD, 0x77, 0x34, 0xEC, 0xB3, 0xEC, 0xEE, 0x4E, 0xEF, 0xEF, 0x7A, 0xFD, 0x22, 0x70, 0xE2, 0xE6, 0x0A, 0xDC, 0xE0, 0xBA, 0x2F, 0xAC, 0xE6, 0x44, 0x4E, 0x9A, 0x4B, 0x41, 0xBA, 0x73, 0x8D, 0x6C, 0x72, 0xFB, 0x16, 0x69, 0x16, 0x03, 0xC1, 0x8E, 0x0E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };
	static constexpr uint8_t c_AES256ECBCiphertext[64 + 16] = { 0xF3, 0xEE, 0xD1, 0xBD, 0xB5, 0xD2, 0xA0, 0x3C, 0x06, 0x4B, 0x5A, 0x7E, 0x3D, 0xB1, 0x81, 0xF8, 0x59, 0x1C, 0xCB, 0x10, 0xD4, 0x10, 0xED, 0x26, 0xDC, 0x5B, 0xA7, 0x4A, 0x31, 0x36, 0x28, 0x70, 0xB6, 0xED, 0x21, 0xB9, 0x9C, 0xA6, 0xF4, 0xF9, 0xF1, 0x53, 0xE7, 0xB1, 0xBE, 0xAF, 0xED, 0x1D, 0x23, 0x30, 0x4B, 0x7A, 0x39, 0xF9, 0xF3, 0xFF, 0x06, 0x7D, 0x8D, 0x8F, 0x9E, 0x24, 0xEC, 0xC7, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };

	static constexpr uint8_t c_AESCBCIV[16]                 = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
	static constexpr uint8_t c_AES128CBCCiphertext[64 + 16] = { 0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D, 0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2, 0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16, 0x3F, 0xF1, 0xCA, 0xA1, 0x68, 0x1F, 0xAC, 0x09, 0x12, 0x0E, 0xCA, 0x30, 0x75, 0x86, 0xE1, 0xA7, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };
	static constexpr uint8_t c_AES192CBCCiphertext[64 + 16] = { 0x4F, 0x02, 0x1D, 0xB2, 0x43, 0xBC, 0x63, 0x3D, 0x71, 0x78, 0x18, 0x3A, 0x9F, 0xA0, 0x71, 0xE8, 0xB4, 0xD9, 0xAD, 0xA9, 0xAD, 0x7D, 0xED, 0xF4, 0xE5, 0xE7, 0x38, 0x76, 0x3F, 0x69, 0x14, 0x5A, 0x57, 0x1B, 0x24, 0x20, 0x12, 0xFB, 0x7A, 0xE0, 0x7F, 0xA9, 0xBA, 0xAC, 0x3D, 0xF1, 0x02, 0xE0, 0x08, 0xB0, 0xE2, 0x79, 0x88, 0x59, 0x88, 0x81, 0xD9, 0x20, 0xA9, 0xE6, 0x4F, 0x56, 0x15, 0xCD, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };
	static constexpr uint8_t c_AES256CBCCiphertext[64 + 16] = { 0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA, 0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6, 0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D, 0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D, 0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF, 0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61, 0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC, 0xDA, 0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 };

	static void TestAES128_ECBEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES128Key, 16);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES128ECBCiphertext, 64) == 0);
	}

	static void TestAES128_ECBDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES128Key, 16);
		result                     = result && Crypto::AES_DecryptData(state, c_AES128ECBCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	static void TestAES192_ECBEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES192Key, 24);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES192ECBCiphertext, 64) == 0);
	}

	static void TestAES192_ECBDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES192Key, 24);
		result                     = result && Crypto::AES_DecryptData(state, c_AES192ECBCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	static void TestAES256_ECBEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES256Key, 32);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES256ECBCiphertext, 64) == 0);
	}

	static void TestAES256_ECBDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_ECB_Init(&state, c_AES256Key, 32);
		result                     = result && Crypto::AES_DecryptData(state, c_AES256ECBCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	static void TestAES128_CBCEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES128Key, 16, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES128CBCCiphertext, 64) == 0);
	}

	static void TestAES128_CBCDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES128Key, 16, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_DecryptData(state, c_AES128CBCCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	static void TestAES192_CBCEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES192Key, 24, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES192CBCCiphertext, 64) == 0);
	}

	static void TestAES192_CBCDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES192Key, 24, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_DecryptData(state, c_AES192CBCCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	static void TestAES256_CBCEncrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES256Key, 32, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_EncryptData(state, c_AESPlaintext, 64, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_EncryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AES256CBCCiphertext, 64) == 0);
	}

	static void TestAES256_CBCDecrypt()
	{
		uint8_t         buffer[128];
		Crypto::ssize_t bufferSize = 128;
		void*           state      = nullptr;
		bool            result     = Crypto::AES_CBC_Init(&state, c_AES256Key, 32, c_AESCBCIV, 16);
		result                     = result && Crypto::AES_DecryptData(state, c_AES256CBCCiphertext, 64 + 16, buffer, &bufferSize);
		bufferSize                 = 128 - bufferSize;
		result                     = result && Crypto::AES_DecryptFinal(state, nullptr, 0, buffer + bufferSize, &bufferSize);
		Crypto::AES_Destroy(state);
		Testing::Assert(result && memcmp(buffer, c_AESPlaintext, 64) == 0);
	}

	void TestCrypto()
	{
		Testing::PushGroup("Crypto");
		Testing::PushGroup("\"abc\"");
		Testing::Test("SHA1", TestSHA_1<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_1<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_1<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_1<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_1<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_1<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_1<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_1<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_1<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();

		Testing::PushGroup("\"\"");
		Testing::Test("SHA1", TestSHA_2<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_2<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_2<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_2<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_2<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_2<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_2<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_2<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_2<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();

		Testing::PushGroup("\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"");
		Testing::Test("SHA1", TestSHA_3<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_3<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_3<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_3<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_3<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_3<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_3<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_3<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_3<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();

		Testing::PushGroup("\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"");
		Testing::Test("SHA1", TestSHA_4<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_4<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_4<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_4<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_4<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_4<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_4<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_4<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_4<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();

		Testing::PushGroup("1 million 'a'");
		Testing::Test("SHA1", TestSHA_5<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_5<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_5<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_5<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_5<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_5<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_5<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_5<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_5<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();

		/*Testing::PushGroup("\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno\" repeated 16777216 times");
		Testing::Test("SHA1", TestSHA_6<Crypto::ESHAFunction::SHA1>);
		Testing::Test("SHA2-224", TestSHA_6<Crypto::ESHAFunction::SHA2_224>);
		Testing::Test("SHA2-256", TestSHA_6<Crypto::ESHAFunction::SHA2_256>);
		Testing::Test("SHA2-384", TestSHA_6<Crypto::ESHAFunction::SHA2_384>);
		Testing::Test("SHA2-512", TestSHA_6<Crypto::ESHAFunction::SHA2_512>);
		Testing::Test("SHA3-224", TestSHA_6<Crypto::ESHAFunction::SHA3_224>);
		Testing::Test("SHA3-256", TestSHA_6<Crypto::ESHAFunction::SHA3_256>);
		Testing::Test("SHA3-384", TestSHA_6<Crypto::ESHAFunction::SHA3_384>);
		Testing::Test("SHA3-512", TestSHA_6<Crypto::ESHAFunction::SHA3_512>);
		Testing::PopGroup();*/

		Testing::PushGroup("AES ECB");
		Testing::Test("AES-128 Encrypt", TestAES128_ECBEncrypt);
		Testing::Test("AES-192 Encrypt", TestAES192_ECBEncrypt);
		Testing::Test("AES-256 Encrypt", TestAES256_ECBEncrypt);
		Testing::Test("AES-128 Decrypt", TestAES128_ECBDecrypt);
		Testing::Test("AES-192 Decrypt", TestAES192_ECBDecrypt);
		Testing::Test("AES-256 Decrypt", TestAES256_ECBDecrypt);
		Testing::PopGroup();

		Testing::PushGroup("AES CBC");
		Testing::Test("AES-128 Encrypt", TestAES128_CBCEncrypt);
		Testing::Test("AES-192 Encrypt", TestAES192_CBCEncrypt);
		Testing::Test("AES-256 Encrypt", TestAES256_CBCEncrypt);
		Testing::Test("AES-128 Decrypt", TestAES128_CBCDecrypt);
		Testing::Test("AES-192 Decrypt", TestAES192_CBCDecrypt);
		Testing::Test("AES-256 Decrypt", TestAES256_CBCDecrypt);
		Testing::PopGroup();
	}
} // namespace Testing